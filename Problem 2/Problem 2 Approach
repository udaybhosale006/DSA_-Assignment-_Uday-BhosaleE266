The problem asks us to rearrange a singly linked list so that all nodes at odd positions appear first, followed by all nodes at even positions, while maintaining the relative order of nodes within each group. The first node is considered odd, the second node even, and so on. To solve this efficiently, we can use two pointers — one for tracking odd-indexed nodes and another for even-indexed nodes — without creating any new nodes, ensuring O(1) extra space and O(n) time complexity.
We start by assigning two pointers: odd pointing to the first node (head) and even pointing to the second node (head->next). We also store the starting point of the even list (evenHead) because we’ll need to connect it at the end. Then, we iterate through the list while both even and even->next are not null. In each iteration, we adjust the links so that the odd pointer skips the even node and points to the next odd node (odd->next = even->next), and then move the odd pointer forward. Similarly, we adjust the even pointer to skip the newly linked odd node (even->next = odd->next) and move it forward as well. This process effectively separates odd and even nodes while preserving their original order.
Once we reach the end of the list, we simply connect the last odd node (odd->next) to the head of the even list (evenHead). This combines both sequences into a single reordered list where all odd-positioned nodes come first, followed by all even-positioned ones. The algorithm runs in linear time because it processes each node only once and uses constant additional space since it only rearranges existing pointers.
